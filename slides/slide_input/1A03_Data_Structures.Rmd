---
title: "Vectors, Lists and Dataframes"
output:
  slidy_presentation:
    duration: 45
    fig_height: 3
    fig_width: 6
  beamer_presentation:
    fonttheme: professionalfonts
---



## Introducing vectors

In R, every variable is a vector. Think of a set of contiguous cells in a spreadsheet. 

```{r eval=TRUE}
set.seed(1234)
e  <- rnorm(100)
X1 <- 1:10
```

Here, `e` is a vector with `N` values. `X1` is the sequence of integers from 1 through 10. 

Vectors can grow and shrink automatically. No need to move cells around on a sheet. No need to copy formulas or change named ranges.



## Vector properties

* Every element in a vector must be the same type. 
    * R will change data types if they are not!
    * Different types are possible by using a list or a data frame (later)
* Vectors have one dimension
    * Higher dimensions are possible via matrices and arrays
* Possible to add metadata (like names) via attributes



## Vector construction

Vectors are constructed in one of several ways:

* Return from a function or operation
    * `seq`, `rep`, `sample`, `rnorm`,  etc.
* Concatenation
* Growth by assignment



## `seq`

`seq` is used often to generate a sequence of values. The colon operator `:` is a shortcut for a sequence of integers.

```{r }
pies = seq(from = 0, by = pi, length.out = 5)
i <- 1:5
year = 2000:2004
```


```{r echo=FALSE}
library(rblocks)
i <- 1:5
block = make_block(i, type = 'vector')
block
```



## `rep`

The `rep` function will replicate its input 
```{r }
i = rep(pi, 100)
head(i)
```

## Concatenation

The `c()` function will concatenate values.



```{r results='hide'}
i <- c(1, 2, 3, 4, 5)
j <- c(6, 7, 8, 9, 10)
k <- c(i, j)
l <- c(1:5, 6:10)
```



```{r echo=FALSE}
i = c(1, 2, 3, 4, 5)
j = c(6, 7, 8, 9, 10)
k = c(i, j)
block_i = make_block(i, type = 'vector')
block_j = make_block(j, type = 'vector')
block_i[1:5] = "red"
block_j[1:5] = "blue"
block_k = make_block(c(block_i,block_j), type='vector')
block_k[1:5] = "red"
block_k[6:10] <- "blue"

block_i
block_j


block_k
```



## Growth by assignment

Assigning a value beyond a vectors limits will automatically grow the vector. Interim values are assigned `NA`.

```{r }
i <- 1:10
i[30] = pi
i
```



## Vector access - by index

Vectors may be accessed by their numeric indices. Remember, ':' is shorthand to generate a sequence.

```{r }
set.seed(1234)
e <- rnorm(100)
e[1]
e[1:4]
e[c(1,3)]
```



## Vector access - logical access

Vectors may be accessed logically. This may be done by passing in a logical vector, or a logical expression.

```{r }
i = 5:9
i[c(TRUE, FALSE, FALSE, FALSE, TRUE)]
i[i > 7]
b = i > 7
b
i[b]
```



## `which`

The `which` function returns indices that match a logical expression.

```{r }
i <- 11:20
which(i > 12)
i[which(i > 12)]
```



## `sample`

The `sample` function will generate a random sample. Great to use for randomizing a vector.

```{r }
months <- c("January", "February", "March", "April"
            , "May", "June", "July", "August"
            , "September", "October", "November", "December")

set.seed(1234)
mixedMonths <- sample(months)
head(mixedMonths)
```

Get lots of months with the `size` parameter:
```{r }
set.seed(1234)
lotsOfMonths <- sample(months, size = 100, replace = TRUE)
head(lotsOfMonths)
```



## `sample` II

Sample may also be used within the indexing of the vector itself:

```{r }
set.seed(1234)
moreMonths <- months[sample(1:12, replace=TRUE, size=100)]
head(moreMonths)

# Cleaner with sample.int
set.seed(1234)
evenMoreMonths <- months[sample.int(length(months), size=100, replace=TRUE)]
head(evenMoreMonths)
```



## `order`

The function `order` will return the indices of the vector in order.

```{r }
set.seed(1234)
x <- sample(1:10)
x
order(x)
x[order(x)]
```



## Vector arithmetic

Vectors may be used in arithmetic operations. 
  
```{r eval=FALSE}
B0 <- 5
B1 <- 1.5

set.seed(1234)

e <- rnorm(N, mean = 0, sd = 1)
X1 <- rep(seq(1,10),10)

Y <- B0 + B1 * X1 + e
```

Y is now a vector with length equal to the longest vector used in the calculation.

Question: B0 and B1 are vectors of length 1. 

X1 and e are vectors of length 100. 

How are they combined?




## Recycling

R will "recycle" vectors until there are enough elements to perform an operation. Everything gets as "long" as the longest vector in the operation. For scalar operations on a vector this doesn't involve any drama. Try the following code:

```{r size='tiny'}
vector1 = 1:10
vector2 = 1:5
scalar = 3

print(vector1 + scalar)
print(vector2 + scalar)
print(vector1 + vector2)
```



## Set theory - Part I

The `%in%` operator will return a logical vector indicating whether or not an element of the first set is contained in the second set.

```{r }
x <- 1:10
y <- 5:15
x %in% y
```



## Set theory - Part II

* `union`
* `intersect`
* `setdiff`
* `setequal`
* `is.element`

```{r eval = FALSE}
?union
```

```{r }
x <- 1900:1910
y <- 1905:1915
intersect(x, y)
setdiff(x, y)
setequal(x, y)
is.element(1941, y)
```



## Summarization

Loads of functions take vector input and return scalar output. Translation of a large sest of numbers into a few, informative values is one of the cornerstones of statistics.

```{r eval=FALSE}
x = 1:50
sum(x)
mean(x)
max(x)
length(x)
var(x)
```



## Vectors 

Vectors are like atoms. If you understand vectors- how to create them, how to manipulate them, how to access the elements, you're well on your way to grasping how to handle other objects in R. 

Vectors may combine to form molecules, but fundamentally, _everything_ in R is a vector.



## Exercise - Vectors

Create a vector of length 10, with years starting from 1980.

Create a vector with values from 1972 to 2012 in increments of four (1972, 1976, 1980, etc.)

Construct the following vectors (feel free to use the `VectorQuestion.R` script):
```{r }
FirstName <- c("Richard", "James", "Ronald", "Ronald"
              , "George", "William", "William", "George"
              , "George", "Barack", "Barack")
LastName <- c("Nixon", "Carter", "Reagan", "Reagan"
              , "Bush", "Clinton", "Clinton", "Bush"
              , "Bush", "Obama", "Obama")
ElectionYear <- seq(1972, 2012, 4)
```

* List the last names in alphabetical order
* List the years in order by first name.
* Create a vector of years when someone named "George" was elected.
* How many Georges were elected before 1996?
* Generate a random sample of 100 presidents.



## Answer
```{r }
LastName[order(LastName)]
ElectionYear[order(FirstName)]
ElectionYear[FirstName == 'George']
myLogical <- (FirstName == 'George') & (ElectionYear < 1996)
length(which(myLogical))
sum(myLogical)

sample(LastName, 100, replace = TRUE)
```



## Lists

Lists have data of arbitrary complexity. Any type, any length. Note the new `[[ ]]` double bracket operator.

```{r }
x <- list()
typeof(x)
x[[1]] <- c("Hello", "there", "this", "is", "a", "list")
x[[2]] <- c(pi, exp(1))
summary(x)
str(x)
```



## Lists

```{r echo=FALSE}
make_block(x)
```



## [ vs. [[

`[` is (almost always) used to set and return an element of the same type as the _containing_ object.

`[[` is used to set and return an element of the same type as the _contained_ object.

This is why we use `[[` to set an item in a list. 

Don't worry if this doesn't make sense yet. It's difficult for most R programmers.



## Recursive storage

Lists can contain other lists as elements.

```{r }
y <- list()
y[[1]] <- "Lou Reed"
y[[2]] <- 45

x[[3]] <- y
```

```{r echo=FALSE}
make_block(x)
```



## List metadata

Again, typically names. However, these become very important for lists. Names are handled with the special `$` operator. `$` permits access to a single element. (A single element of a list can be a vector!)

```{r}
y[[1]] <- c("Lou Reed", "Patti Smith")
y[[2]] <- c(45, 63)

names(y) <- c("Artist", "Age")

y$Artist
y$Age
```



## `lapply`

`lapply` is one of many functions which may be applied to lists. Can be difficult at first, but very powerful. Applies the same function to each element of a list.

```{r }
myList <- list(firstVector = c(1:10)
               , secondVector = c(89, 56, 84, 298, 56)
               , thirdVector = c(7,3,5,6,2,4,2))
lapply(myList, mean)
lapply(myList, median)
lapply(myList, sum)
```



## Why `lapply`? 

Two reasons:

1. It's expressive. A loop is a lot of code which does little to clarify intent. `lapply` indicates that we want to apply the same function to each element of a list. Think of a formula that exists as a column in a spreadsheet.
2. It's easier to type at an interactive console. In its very early days, `S` was fully interactive. Typing a `for` loop at the console is a tedius and unnecessary task.



## Summary functions

Because lists are arbitrary, we can't expect functions like `sum` or `mean` to work. Use `lapply` to summarize particular list elements.



## List Questions

* Create a list with two elements. Have the first element be a vector with 100 numbers. Have the second element be a vector with 100 dates. Give your list the names: "Claim" and "AccidentDate".
* What is the average value of a claim?



## Answers

```{r }
myList <- list()
myList$Claims <- rlnorm(100, log(10000))
myList$AccidentDate <- sample(seq.Date(as.Date('2000-01-01'), as.Date('2009-12-31'), length.out = 1000), 100)
mean(myList$Claims)
```




# Matrices

## Defining a matrix

Defining a matrix is straightforward. Use the option byrow=TRUE to fill across the rows.
```{r}
A<-matrix(1:6,nrow=2)
A
```
```{r}
A<-matrix(1:6,nrow=2,byrow=TRUE)
A
```

## Recycling

Recycling will occur if needed and you'll get a warning.

```{r}
A<-matrix(1:6,nrow=2,ncol=5)
A

```

## Matrices are their own class

```{r}
class(A)
attributes(A)
attr(A,"dim")
```

***

```{r}
nrow(A)
dim(A)[1]
ncol(A)
dim(A)[2]

```

## Selecting individual elements, rows and columns.

```{r}
A[2,2]
A[1,]
A[,2]
```


***

Note that the class of a single row or column reverts to a vector. To keep it as a matrix, use `drop=FALSE`.

```{r}
class(A[1,])
class(A[1,,drop=FALSE])
A[1,,drop=FALSE]
```

## Submatrices

```{r}
set.seed(6345789)
x<-sample(1:20,size=9,replace=TRUE)
m1<-matrix(x,nrow=3)
m1
```

***
Select the 1st and 3rd rows and the 2nd and 3rd columns.
```{r}
m1[c(1,3),c(2,3)]
```

```{r}
m1[-2,-1]
```

## Using Row and Column Names

```{r}
rownames(m1)
colnames(m1)
rownames(m1)<-c("row1","row2","row3")
colnames(m1)<-c("col1","col2","col3")
m1[c("row1","row2"),c("col2","col3")]
```



## Character matrices and mixed matrices

```{r}

B<-matrix(c("a","b","c","d"),nrow=2);B
C<-list(1,2,3,"a")
dim(C)<-c(2,2);C
```


## Using rbind and cbind to add rows and columns

```{r}
A<-matrix(1:6,nrow=2)
B<-rbind(A,7:9)
B
dim(B)
```

***

```{r}
C<-cbind(A,10:11)
C
dim(C)
```



## Matrix Operations

```{r}
A<-matrix(1:6,nrow=2)
3*A
A+A
```

## Matrix Operations

`A^2` squares each element. The transpose of A is given by `t(A)`.
```{r}
A<-matrix(1:6,nrow=2)
A^2
t(A)
```

## Matrix Multiplication

Remember that when multiplying two matrices AB the number of columns of A has to equal the number of rows in B.

```{r}
B<-matrix(c(-1,6,8,7,4,1),nrow=3)
C<-A %*% B
dim(C)
C
# B %*% A will give an error
```

## Solving Equations

Solve the following system of equations.
$$ x + y =8$$
$$ 3x + 2y=18$$
```{r}
(A<-matrix(c(1,1,3,2),nrow=2,byrow=TRUE))
(B<-matrix(c(8,18),nrow=2))
```

## Solution

First, check that the determinant is non-zero so that it has a solution.
```{r}
det(A)
```
Then use `solve`.
```{r}
solve(A,B)
```

## Computing the inverse of a matrix

`solve` also gives the inverse of a matrix.
```{r}
solve(A)
solve(A)%*%B
```

## Eigenvalues

`eigen` computes eigenvalues and eigenvectors. 
```{r}
eigen(A)
```

## Diagonal Matrices

`diag` extract the diagonal of a matrix and also creates a diagonal matrix, depending on its argument.
```{r}
diag(A)
diag(c(2,4,6,8))
```

## Row/Column Operations

`rowsums, colsums, rowmeans, colmeans` give the sums and means of rows and columns.

```{r}
(A<-matrix(1:6,nrow=2))
rowSums(A)
colSums(A)
```

***
```{r}
rowMeans(A)
colMeans(A)
```



## Exercise: Create a matrix that gives the following table. 

Team      | Wins   | Losses  | Pct
----------|--------|---------|----
Toronto   |    93  |   69    |0.574
New York  |    87  |   75    |0.537
Baltimore |    81  |   81    |0.500
Tampa Bay |    80  |   82    |0.494
Boston    |    78  |   84    |0.481


## Solution

```{r}
teams<-c("Toronto","New York","Baltimore","Tampa Bay","Boston")
wins<-c(93,87,81,80,78)
losses<-c(69,75,81,82,84)
```

```{r}
alEast<-matrix(c(wins,losses),nrow=5,byrow=FALSE)
alEast
```

## Add row and column names
```{r}
rownames(alEast)<-teams
colnames(alEast)<-c("Wins","Losses")
alEast
```

## Add winning percentage

```{r}
Pct<-round(alEast[,"Wins"]/(alEast[,"Wins"]+alEast[,"Losses"]),3)
alEast<-cbind(alEast,Pct)
alEast
```



## What if we want the team names to be a column in the matrix?
```{r}
alEast<-matrix(c(teams,wins,losses),nrow=5,byrow=FALSE)
alEast
```

## Try to coerce column to numeric
```{r}
class(alEast[,2])
as.numeric(alEast[,2])
alEast[,2]<-as.numeric(alEast[,2])
alEast
```

## Use `cbind` to put them together

```{r}
alEast<-cbind(teams,wins,losses)
alEast
class(alEast)
```

We need a matrix-like structure that allows columns to be of different classes.

# Data Frames

##
Data frames allow for columns with different classes.
```{r}
alEast<-data.frame(Team=teams,W=wins,L=losses)
alEast
class(alEast)

```

## Classes are different.

```{r}
sapply(alEast,class)
```

Use `stringsAsFactors=FALSE` to use characters instead of factors.

```{r}
alEast<-data.frame(Team=teams,W=wins,L=losses,
                   stringsAsFactors=FALSE)
sapply(alEast,class)
```

## Selecting rows and columns

We can access rows and columns the same way as matrices. 

```{r}
alEast[,"Team",drop=FALSE]
class(alEast[,"Team",drop=FALSE])
```

## We can also access them like elements of a list.

```{r}
alEast$W

alEast[[2]]

dim(alEast)
```

## Attributes of a data frame
```{r}
attributes(alEast)
```


## Lahman Baseball Database

R package created from [Sean Lahman's](http://seanlahman.com/) baseball database. We'll look at the Teams dataframe.
```{r}
library(Lahman)
class(Teams)
dim(Teams)
```

## Column and row names

Instead of `colnames`, we just use `names`.

```{r}
names(Teams)
```

***

Instead of `rownames`, we use `row.names`. In this case they're just the row numbers. We also have commands to get the number of rows and columns.

```{r}
head(row.names(Teams))
nrow(Teams)
ncol(Teams)
```

## Exploring data frames

You've already seen `head` and `tail`. They let you see the top and bottom of the data frame. An additional argument lets you give the number of rows to be shown.

```{r}
head(Teams,6)
```

***
```{r}
tail(Teams,4)
```

## Summary

```{r}
summary(Teams)
```

## Structure
```{r}
str(Teams)
```

## Data Frame Operations

* select - pick columns by name
* filter - keep rows matching criteria
* mutate - add new variables
* arrange - reorder rows
* summarize - reduce variables to values

## Select

Let's get a data frame similar to theone we just created byselecting the Year, League, Team, Division, Wins, and Losses.

```{r}
myTeams<-Teams[,c("yearID","lgID","teamID","divID","W","L")]
head(myTeams)
```

***
Use `str` to see what the league ID and division ID's are.
```{r}
str(myTeams)
unique(myTeams$divID)
```

## Filter

Find the 2014 AL East standings.
```{r}
alEast2014<-myTeams[myTeams$yearID==2014 & myTeams$lgID=="AL" 
                    & myTeams$divID=="E",]
alEast2014
```

***
Let's eliminate the columns that are the same.
```{r}
alEast2014<-alEast2014[,c("teamID","W","L")]
names(alEast2014)<-c("Team","Wins","Losses")
alEast2014
```


## Mutate

Add the percentage of wins.

```{r}
alEast2014$Pct<-round(alEast2014$Wins/(alEast2014$Wins+alEast2014$Losses),3)
alEast2014
```

## Arrange

List the teams from highest to lowest winning percentage. (Note the - indicates decreasing.)

```{r}
alEast2014[order(-alEast2014$Pct),]
```


## Summarize

Determine the total wins for each of 6 divisions in 2014.

```{r}
mlb2014<-subset(Teams,yearID==2014)
mlb2014<-mlb2014[,c("lgID","divID","W")]
d1<-aggregate(W~lgID+divID,data=mlb2014,sum)
```


# Getting Data in and out of R

## Basics

There's a manual, "R Data Import/Export", located at C:/Program Files/R/R-X.Y.Z/doc/manual/R-data.pdf

### Getting Data In
`read.csv` and `read.fwf` are straightforward to use. Pay attention to the option `stringsAsFactors`.
`read.table` gives you more options. `readLines` will read in a text file and returns a character vector of length the number of lines read.

### Getting Data Out

`write.csv` and `write.table` export data in formats that are read by, e.g. Excel and Access.

## readr and data.table Packages

### readr

The `readr` package has functions for reading and writing csv files (`read_csv` and `write_csv`.) These functions are faster than those included in base R. 

You can read about it at [http://blog.rstudio.org/2015/10/28/readr-0-2-0/](http://blog.rstudio.org/2015/10/28/readr-0-2-0/)

### data.table

`data.table` has a function `fread` that is a "Fast and friendly file finagler." By default it returns a data.table but will return a data frame when the argument `data.table=FALSE` is used.

## Manual data entry

If you're a real masochist, use `edit`. You'll get a spreadsheet interface to enter numbers in.

```{r,eval=FALSE}
x<-data.frame()
x<-edit(x)
```

## Reading from Excel

Use the package `readxl`. It has two functions: `excel_sheets` and `read_excel`.

Choose an excel file using the dialog box and read it into R.

```{r,echo=TRUE,eval=FALSE}
library(readxl)
f1<-file.choose() #opens dialog box
d1<-excel_sheets(f1)
class(d1)
d2<-read_excel(f1) #default is first sheet
```

## Reading from Excel

This is the example from ?read_excel.
```{r}
suppressWarnings(library(readxl))
datasets <- system.file("extdata/datasets.xlsx", package = "readxl")
excel_sheets(datasets)
head(read_excel(datasets,sheet="mtcars"))

```

## Saving and loading R data sets.

When you close R you get the question "Save Workspace Image?" If you answer "Yes" it'll create a copy of your environment and save it in the file .RData. (This uses the `save.image` function.)

If you wish to save only certain objects the use `save` and provide a list of objects and a file name. Some people use .rda as the suffix for these files.


